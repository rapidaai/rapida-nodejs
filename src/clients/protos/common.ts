// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.19.1
// source: common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "";

export enum Source {
  WEB_PLUGIN = 0,
  RAPIDA_APP = 1,
  PYTHON_SDK = 2,
  NODE_SDK = 3,
  GO_SDK = 4,
  TYPESCRIPT_SDK = 5,
  JAVA_SDK = 6,
  PHP_SDK = 7,
  RUST_SDK = 8,
  UNRECOGNIZED = -1,
}

export function sourceFromJSON(object: any): Source {
  switch (object) {
    case 0:
    case "WEB_PLUGIN":
      return Source.WEB_PLUGIN;
    case 1:
    case "RAPIDA_APP":
      return Source.RAPIDA_APP;
    case 2:
    case "PYTHON_SDK":
      return Source.PYTHON_SDK;
    case 3:
    case "NODE_SDK":
      return Source.NODE_SDK;
    case 4:
    case "GO_SDK":
      return Source.GO_SDK;
    case 5:
    case "TYPESCRIPT_SDK":
      return Source.TYPESCRIPT_SDK;
    case 6:
    case "JAVA_SDK":
      return Source.JAVA_SDK;
    case 7:
    case "PHP_SDK":
      return Source.PHP_SDK;
    case 8:
    case "RUST_SDK":
      return Source.RUST_SDK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Source.UNRECOGNIZED;
  }
}

export function sourceToJSON(object: Source): string {
  switch (object) {
    case Source.WEB_PLUGIN:
      return "WEB_PLUGIN";
    case Source.RAPIDA_APP:
      return "RAPIDA_APP";
    case Source.PYTHON_SDK:
      return "PYTHON_SDK";
    case Source.NODE_SDK:
      return "NODE_SDK";
    case Source.GO_SDK:
      return "GO_SDK";
    case Source.TYPESCRIPT_SDK:
      return "TYPESCRIPT_SDK";
    case Source.JAVA_SDK:
      return "JAVA_SDK";
    case Source.PHP_SDK:
      return "PHP_SDK";
    case Source.RUST_SDK:
      return "RUST_SDK";
    case Source.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Criteria {
  key: string;
  value: string;
  logic: string;
}

export interface Error {
  errorCode: number;
  errorMessage: string;
  humanMessage: string;
}

export interface Paginate {
  page: number;
  pageSize: number;
}

export interface Paginated {
  currentPage: number;
  totalItem: number;
}

export interface Ordering {
  column: string;
  order: string;
}

export interface User {
  id: number;
  name: string;
  email: string;
  role: string;
  createdDate?: Date | undefined;
  status: string;
}

export interface BaseResponse {
  code: number;
  success: boolean;
  data: { [key: string]: string };
  error?: Error | undefined;
}

export interface BaseResponse_DataEntry {
  key: string;
  value: string;
}

export interface Metadata {
  id: number;
  key: string;
  value: string;
}

export interface Variable {
  id: number;
  name: string;
  type: string;
  defaultValue?: string | undefined;
  in?: string | undefined;
  required: boolean;
  label?: string | undefined;
}

export interface ProviderModelParameter {
  id: number;
  providerModelVariableId: number;
  value: string;
}

export interface Provider {
  id: number;
  name: string;
  description: string;
  humanName: string;
  image: string;
  website: string;
  status: string;
  connectConfiguration: Variable[];
}

export interface ProviderModelVariable {
  id: number;
  providerModelId: number;
  key: string;
  name: string;
  description: string;
  defaultValue: string;
  type: string;
  place: string;
  metadatas: Metadata[];
}

export interface ProviderModel {
  id: number;
  name: string;
  description: string;
  humanName: string;
  category: string;
  status: string;
  owner: string;
  provider?: Provider | undefined;
  parameters: ProviderModelVariable[];
  metadatas: Metadata[];
  providerId: number;
  endpoint: string;
}

export interface Tag {
  id: number;
  tag: string[];
}

export interface Organization {
  id: number;
  name: string;
  description: string;
  industry: string;
  contact: string;
  size: string;
}

export interface Metric {
  name: string;
  value: string;
  description: string;
}

export interface Content {
  name: string;
  /** audio, image, video, text etc */
  contentType: string;
  /** from raw string to url all can be */
  contentFormat: string;
  /** actual content */
  content: Uint8Array;
  /**
   * added meta data incase you want to add something which is not supported in
   * future
   */
  meta?: { [key: string]: any } | undefined;
}

export interface Message {
  /** role for the message */
  role: string;
  /** contents */
  contents: Content[];
  /** tool call */
  toolCalls: ToolCall[];
}

export interface Event {
  name: string;
  meta?: { [key: string]: any } | undefined;
  time?: Date | undefined;
}

export interface ToolCall {
  /** tool call id */
  id: string;
  /**  */
  type: string;
  /** tool call is function than the function and their parameter */
  function?: FunctionCall | undefined;
}

export interface FunctionCall {
  /** name of function call */
  name: string;
  /** argument that is string and that can be passed */
  arguments: string;
  /** structure argument */
  args?: { [key: string]: any } | undefined;
}

export interface Knowledge {
  id: number;
  name: string;
  description: string;
  visibility: string;
  language: string;
  embeddingProviderModelId: number;
  embeddingProviderModel?: ProviderModel | undefined;
  status: string;
  createdBy: number;
  createdUser?: User | undefined;
  updatedBy: number;
  updatedUser?: User | undefined;
  createdDate?: Date | undefined;
  updatedDate?:
    | Date
    | undefined;
  /**  */
  organizationId: number;
  projectId: number;
  organization?: Organization | undefined;
  knowledgeTag?: Tag | undefined;
  documentCount: number;
  tokenCount: number;
  wordCount: number;
  embeddingProviderId: number;
}

export interface AgentPromptTemplate {
  type: string;
  prompt: string;
  promptVariables: Variable[];
}

/** Define message for TextPrompt */
export interface TextPrompt {
  role: string;
  content: string;
}

export interface FilePrompt {
  name: string;
  accepts: string;
}

/** Define message for TextChatCompletePrompt */
export interface TextChatCompletePrompt {
  prompt: TextPrompt[];
  promptVariables: Variable[];
}

export interface TextCompletePrompt {
  prompt?: TextPrompt | undefined;
  promptVariables: Variable[];
}

export interface TextToImagePrompt {
  prompt?: TextPrompt | undefined;
  promptVariables: Variable[];
}

export interface TextToSpeechPrompt {
  prompt?: TextPrompt | undefined;
  promptVariables: Variable[];
}

export interface SpeechToTextPrompt {
  prompt?: FilePrompt | undefined;
  promptVariables: Variable[];
}

export interface AssistantMessageStage {
  stage: string;
  additionalData: { [key: string]: string };
  timetaken: number;
  lifecycleId: string;
  startTimestamp?: Date | undefined;
  endTimestamp?: Date | undefined;
}

export interface AssistantMessageStage_AdditionalDataEntry {
  key: string;
  value: string;
}

export interface AssistantConversationMessage {
  id: number;
  messageId: string;
  assistantConversationId: number;
  request?: Message | undefined;
  response?: Message | undefined;
  source: string;
  metrics: Metric[];
  status: string;
  createdBy: number;
  updatedBy: number;
  suggestedQuestions: string[];
  stages: AssistantMessageStage[];
  createdDate?: Date | undefined;
  updatedDate?: Date | undefined;
  assistantId: number;
  assistantProviderModelId: number;
  metadata: Metadata[];
}

export interface AssistantConversationContext {
  id: number;
  context: string;
  metadata?: { [key: string]: any } | undefined;
}

export interface AssistantConversation {
  id: number;
  userId: number;
  assistantId: number;
  name: string;
  projectId: number;
  organizationId: number;
  source: string;
  createdBy: number;
  updatedBy: number;
  user?: User | undefined;
  assistantProviderModelId: number;
  assistantConversationMessage: AssistantConversationMessage[];
  identifier: string;
  status: string;
  createdDate?: Date | undefined;
  updatedDate?: Date | undefined;
  contexts: AssistantConversationContext[];
  /** a conversation metrics and other analytical markers */
  metrics: Metric[];
  /** google.protobuf.Struct arguments = 31; */
  metadata: Metadata[];
}

export interface GetAllAssistantConversationRequest {
  assistantId: number;
  paginate?: Paginate | undefined;
  criterias: Criteria[];
  source: Source;
}

export interface GetAllAssistantConversationResponse {
  code: number;
  success: boolean;
  data: AssistantConversation[];
  error?: Error | undefined;
  paginated?: Paginated | undefined;
}

export interface GetAllConversationMessageRequest {
  assistantId: number;
  assistantConversationId: number;
  paginate?: Paginate | undefined;
  criterias: Criteria[];
  order?: Ordering | undefined;
  source: Source;
}

export interface GetAllConversationMessageResponse {
  code: number;
  success: boolean;
  data: AssistantConversationMessage[];
  error?: Error | undefined;
  paginated?: Paginated | undefined;
}

function createBaseCriteria(): Criteria {
  return { key: "", value: "", logic: "" };
}

export const Criteria: MessageFns<Criteria> = {
  encode(message: Criteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.logic !== "") {
      writer.uint32(26).string(message.logic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Criteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logic = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Criteria {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      logic: isSet(object.logic) ? globalThis.String(object.logic) : "",
    };
  },

  toJSON(message: Criteria): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.logic !== "") {
      obj.logic = message.logic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Criteria>, I>>(base?: I): Criteria {
    return Criteria.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Criteria>, I>>(object: I): Criteria {
    const message = createBaseCriteria();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.logic = object.logic ?? "";
    return message;
  },
};

function createBaseError(): Error {
  return { errorCode: 0, errorMessage: "", humanMessage: "" };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== 0) {
      writer.uint32(8).uint64(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.humanMessage !== "") {
      writer.uint32(26).string(message.humanMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.humanMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.Number(object.errorCode) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      humanMessage: isSet(object.humanMessage) ? globalThis.String(object.humanMessage) : "",
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.errorCode !== 0) {
      obj.errorCode = Math.round(message.errorCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.humanMessage !== "") {
      obj.humanMessage = message.humanMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.humanMessage = object.humanMessage ?? "";
    return message;
  },
};

function createBasePaginate(): Paginate {
  return { page: 0, pageSize: 0 };
}

export const Paginate: MessageFns<Paginate> = {
  encode(message: Paginate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).uint32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).uint32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Paginate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Paginate {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: Paginate): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Paginate>, I>>(base?: I): Paginate {
    return Paginate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Paginate>, I>>(object: I): Paginate {
    const message = createBasePaginate();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBasePaginated(): Paginated {
  return { currentPage: 0, totalItem: 0 };
}

export const Paginated: MessageFns<Paginated> = {
  encode(message: Paginated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentPage !== 0) {
      writer.uint32(8).uint32(message.currentPage);
    }
    if (message.totalItem !== 0) {
      writer.uint32(16).uint32(message.totalItem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Paginated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentPage = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalItem = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Paginated {
    return {
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      totalItem: isSet(object.totalItem) ? globalThis.Number(object.totalItem) : 0,
    };
  },

  toJSON(message: Paginated): unknown {
    const obj: any = {};
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.totalItem !== 0) {
      obj.totalItem = Math.round(message.totalItem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Paginated>, I>>(base?: I): Paginated {
    return Paginated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Paginated>, I>>(object: I): Paginated {
    const message = createBasePaginated();
    message.currentPage = object.currentPage ?? 0;
    message.totalItem = object.totalItem ?? 0;
    return message;
  },
};

function createBaseOrdering(): Ordering {
  return { column: "", order: "" };
}

export const Ordering: MessageFns<Ordering> = {
  encode(message: Ordering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.column !== "") {
      writer.uint32(10).string(message.column);
    }
    if (message.order !== "") {
      writer.uint32(18).string(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ordering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrdering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.column = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.order = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ordering {
    return {
      column: isSet(object.column) ? globalThis.String(object.column) : "",
      order: isSet(object.order) ? globalThis.String(object.order) : "",
    };
  },

  toJSON(message: Ordering): unknown {
    const obj: any = {};
    if (message.column !== "") {
      obj.column = message.column;
    }
    if (message.order !== "") {
      obj.order = message.order;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ordering>, I>>(base?: I): Ordering {
    return Ordering.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ordering>, I>>(object: I): Ordering {
    const message = createBaseOrdering();
    message.column = object.column ?? "";
    message.order = object.order ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return { id: 0, name: "", email: "", role: "", createdDate: undefined, status: "" };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.createdDate !== undefined) {
      Timestamp.encode(toTimestamp(message.createdDate), writer.uint32(50).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      createdDate: isSet(object.createdDate) ? fromJsonTimestamp(object.createdDate) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.createdDate !== undefined) {
      obj.createdDate = message.createdDate.toISOString();
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    message.createdDate = object.createdDate ?? undefined;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseBaseResponse(): BaseResponse {
  return { code: 0, success: false, data: {}, error: undefined };
}

export const BaseResponse: MessageFns<BaseResponse> = {
  encode(message: BaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    Object.entries(message.data).forEach(([key, value]) => {
      BaseResponse_DataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = BaseResponse_DataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.data[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaseResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BaseResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaseResponse>, I>>(base?: I): BaseResponse {
    return BaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaseResponse>, I>>(object: I): BaseResponse {
    const message = createBaseBaseResponse();
    message.code = object.code ?? 0;
    message.success = object.success ?? false;
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBaseResponse_DataEntry(): BaseResponse_DataEntry {
  return { key: "", value: "" };
}

export const BaseResponse_DataEntry: MessageFns<BaseResponse_DataEntry> = {
  encode(message: BaseResponse_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseResponse_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaseResponse_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BaseResponse_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaseResponse_DataEntry>, I>>(base?: I): BaseResponse_DataEntry {
    return BaseResponse_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaseResponse_DataEntry>, I>>(object: I): BaseResponse_DataEntry {
    const message = createBaseBaseResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { id: 0, key: "", value: "" };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.id = object.id ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVariable(): Variable {
  return { id: 0, name: "", type: "", defaultValue: undefined, in: undefined, required: false, label: undefined };
}

export const Variable: MessageFns<Variable> = {
  encode(message: Variable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.defaultValue !== undefined) {
      writer.uint32(34).string(message.defaultValue);
    }
    if (message.in !== undefined) {
      writer.uint32(42).string(message.in);
    }
    if (message.required !== false) {
      writer.uint32(48).bool(message.required);
    }
    if (message.label !== undefined) {
      writer.uint32(58).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.in = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variable {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : undefined,
      in: isSet(object.in) ? globalThis.String(object.in) : undefined,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
    };
  },

  toJSON(message: Variable): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.in !== undefined) {
      obj.in = message.in;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Variable>, I>>(base?: I): Variable {
    return Variable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Variable>, I>>(object: I): Variable {
    const message = createBaseVariable();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.defaultValue = object.defaultValue ?? undefined;
    message.in = object.in ?? undefined;
    message.required = object.required ?? false;
    message.label = object.label ?? undefined;
    return message;
  },
};

function createBaseProviderModelParameter(): ProviderModelParameter {
  return { id: 0, providerModelVariableId: 0, value: "" };
}

export const ProviderModelParameter: MessageFns<ProviderModelParameter> = {
  encode(message: ProviderModelParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.providerModelVariableId !== 0) {
      writer.uint32(16).uint64(message.providerModelVariableId);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderModelParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderModelParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.providerModelVariableId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderModelParameter {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      providerModelVariableId: isSet(object.providerModelVariableId)
        ? globalThis.Number(object.providerModelVariableId)
        : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ProviderModelParameter): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.providerModelVariableId !== 0) {
      obj.providerModelVariableId = Math.round(message.providerModelVariableId);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderModelParameter>, I>>(base?: I): ProviderModelParameter {
    return ProviderModelParameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderModelParameter>, I>>(object: I): ProviderModelParameter {
    const message = createBaseProviderModelParameter();
    message.id = object.id ?? 0;
    message.providerModelVariableId = object.providerModelVariableId ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProvider(): Provider {
  return {
    id: 0,
    name: "",
    description: "",
    humanName: "",
    image: "",
    website: "",
    status: "",
    connectConfiguration: [],
  };
}

export const Provider: MessageFns<Provider> = {
  encode(message: Provider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.humanName !== "") {
      writer.uint32(34).string(message.humanName);
    }
    if (message.image !== "") {
      writer.uint32(42).string(message.image);
    }
    if (message.website !== "") {
      writer.uint32(50).string(message.website);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    for (const v of message.connectConfiguration) {
      Variable.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Provider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.humanName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.connectConfiguration.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Provider {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      humanName: isSet(object.humanName) ? globalThis.String(object.humanName) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      website: isSet(object.website) ? globalThis.String(object.website) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      connectConfiguration: globalThis.Array.isArray(object?.connectConfiguration)
        ? object.connectConfiguration.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Provider): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.humanName !== "") {
      obj.humanName = message.humanName;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.website !== "") {
      obj.website = message.website;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.connectConfiguration?.length) {
      obj.connectConfiguration = message.connectConfiguration.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Provider>, I>>(base?: I): Provider {
    return Provider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Provider>, I>>(object: I): Provider {
    const message = createBaseProvider();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.humanName = object.humanName ?? "";
    message.image = object.image ?? "";
    message.website = object.website ?? "";
    message.status = object.status ?? "";
    message.connectConfiguration = object.connectConfiguration?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProviderModelVariable(): ProviderModelVariable {
  return {
    id: 0,
    providerModelId: 0,
    key: "",
    name: "",
    description: "",
    defaultValue: "",
    type: "",
    place: "",
    metadatas: [],
  };
}

export const ProviderModelVariable: MessageFns<ProviderModelVariable> = {
  encode(message: ProviderModelVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.providerModelId !== 0) {
      writer.uint32(16).uint64(message.providerModelId);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.defaultValue !== "") {
      writer.uint32(50).string(message.defaultValue);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.place !== "") {
      writer.uint32(66).string(message.place);
    }
    for (const v of message.metadatas) {
      Metadata.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderModelVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderModelVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.providerModelId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.place = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadatas.push(Metadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderModelVariable {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      providerModelId: isSet(object.providerModelId) ? globalThis.Number(object.providerModelId) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      defaultValue: isSet(object.defaultValue) ? globalThis.String(object.defaultValue) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      place: isSet(object.place) ? globalThis.String(object.place) : "",
      metadatas: globalThis.Array.isArray(object?.metadatas)
        ? object.metadatas.map((e: any) => Metadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProviderModelVariable): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.providerModelId !== 0) {
      obj.providerModelId = Math.round(message.providerModelId);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.defaultValue !== "") {
      obj.defaultValue = message.defaultValue;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.place !== "") {
      obj.place = message.place;
    }
    if (message.metadatas?.length) {
      obj.metadatas = message.metadatas.map((e) => Metadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderModelVariable>, I>>(base?: I): ProviderModelVariable {
    return ProviderModelVariable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderModelVariable>, I>>(object: I): ProviderModelVariable {
    const message = createBaseProviderModelVariable();
    message.id = object.id ?? 0;
    message.providerModelId = object.providerModelId ?? 0;
    message.key = object.key ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.defaultValue = object.defaultValue ?? "";
    message.type = object.type ?? "";
    message.place = object.place ?? "";
    message.metadatas = object.metadatas?.map((e) => Metadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProviderModel(): ProviderModel {
  return {
    id: 0,
    name: "",
    description: "",
    humanName: "",
    category: "",
    status: "",
    owner: "",
    provider: undefined,
    parameters: [],
    metadatas: [],
    providerId: 0,
    endpoint: "",
  };
}

export const ProviderModel: MessageFns<ProviderModel> = {
  encode(message: ProviderModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.humanName !== "") {
      writer.uint32(34).string(message.humanName);
    }
    if (message.category !== "") {
      writer.uint32(42).string(message.category);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.owner !== "") {
      writer.uint32(58).string(message.owner);
    }
    if (message.provider !== undefined) {
      Provider.encode(message.provider, writer.uint32(66).fork()).join();
    }
    for (const v of message.parameters) {
      ProviderModelVariable.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.metadatas) {
      Metadata.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.providerId !== 0) {
      writer.uint32(88).uint64(message.providerId);
    }
    if (message.endpoint !== "") {
      writer.uint32(98).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.humanName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.provider = Provider.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.parameters.push(ProviderModelVariable.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadatas.push(Metadata.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.providerId = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderModel {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      humanName: isSet(object.humanName) ? globalThis.String(object.humanName) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      provider: isSet(object.provider) ? Provider.fromJSON(object.provider) : undefined,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => ProviderModelVariable.fromJSON(e))
        : [],
      metadatas: globalThis.Array.isArray(object?.metadatas)
        ? object.metadatas.map((e: any) => Metadata.fromJSON(e))
        : [],
      providerId: isSet(object.providerId) ? globalThis.Number(object.providerId) : 0,
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
    };
  },

  toJSON(message: ProviderModel): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.humanName !== "") {
      obj.humanName = message.humanName;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.provider !== undefined) {
      obj.provider = Provider.toJSON(message.provider);
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ProviderModelVariable.toJSON(e));
    }
    if (message.metadatas?.length) {
      obj.metadatas = message.metadatas.map((e) => Metadata.toJSON(e));
    }
    if (message.providerId !== 0) {
      obj.providerId = Math.round(message.providerId);
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderModel>, I>>(base?: I): ProviderModel {
    return ProviderModel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderModel>, I>>(object: I): ProviderModel {
    const message = createBaseProviderModel();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.humanName = object.humanName ?? "";
    message.category = object.category ?? "";
    message.status = object.status ?? "";
    message.owner = object.owner ?? "";
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? Provider.fromPartial(object.provider)
      : undefined;
    message.parameters = object.parameters?.map((e) => ProviderModelVariable.fromPartial(e)) || [];
    message.metadatas = object.metadatas?.map((e) => Metadata.fromPartial(e)) || [];
    message.providerId = object.providerId ?? 0;
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseTag(): Tag {
  return { id: 0, tag: [] };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    for (const v of message.tag) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      tag: globalThis.Array.isArray(object?.tag) ? object.tag.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tag?.length) {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.id = object.id ?? 0;
    message.tag = object.tag?.map((e) => e) || [];
    return message;
  },
};

function createBaseOrganization(): Organization {
  return { id: 0, name: "", description: "", industry: "", contact: "", size: "" };
}

export const Organization: MessageFns<Organization> = {
  encode(message: Organization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.industry !== "") {
      writer.uint32(34).string(message.industry);
    }
    if (message.contact !== "") {
      writer.uint32(42).string(message.contact);
    }
    if (message.size !== "") {
      writer.uint32(50).string(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Organization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.industry = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contact = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.size = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Organization {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      industry: isSet(object.industry) ? globalThis.String(object.industry) : "",
      contact: isSet(object.contact) ? globalThis.String(object.contact) : "",
      size: isSet(object.size) ? globalThis.String(object.size) : "",
    };
  },

  toJSON(message: Organization): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.industry !== "") {
      obj.industry = message.industry;
    }
    if (message.contact !== "") {
      obj.contact = message.contact;
    }
    if (message.size !== "") {
      obj.size = message.size;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Organization>, I>>(base?: I): Organization {
    return Organization.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Organization>, I>>(object: I): Organization {
    const message = createBaseOrganization();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.industry = object.industry ?? "";
    message.contact = object.contact ?? "";
    message.size = object.size ?? "";
    return message;
  },
};

function createBaseMetric(): Metric {
  return { name: "", value: "", description: "" };
}

export const Metric: MessageFns<Metric> = {
  encode(message: Metric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metric {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Metric): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metric>, I>>(base?: I): Metric {
    return Metric.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metric>, I>>(object: I): Metric {
    const message = createBaseMetric();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseContent(): Content {
  return { name: "", contentType: "", contentFormat: "", content: new Uint8Array(0), meta: undefined };
}

export const Content: MessageFns<Content> = {
  encode(message: Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.contentType !== "") {
      writer.uint32(18).string(message.contentType);
    }
    if (message.contentFormat !== "") {
      writer.uint32(26).string(message.contentFormat);
    }
    if (message.content.length !== 0) {
      writer.uint32(34).bytes(message.content);
    }
    if (message.meta !== undefined) {
      Struct.encode(Struct.wrap(message.meta), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentFormat = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.meta = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      contentFormat: isSet(object.contentFormat) ? globalThis.String(object.contentFormat) : "",
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
      meta: isObject(object.meta) ? object.meta : undefined,
    };
  },

  toJSON(message: Content): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.contentFormat !== "") {
      obj.contentFormat = message.contentFormat;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.meta !== undefined) {
      obj.meta = message.meta;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Content>, I>>(base?: I): Content {
    return Content.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Content>, I>>(object: I): Content {
    const message = createBaseContent();
    message.name = object.name ?? "";
    message.contentType = object.contentType ?? "";
    message.contentFormat = object.contentFormat ?? "";
    message.content = object.content ?? new Uint8Array(0);
    message.meta = object.meta ?? undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return { role: "", contents: [], toolCalls: [] };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    for (const v of message.contents) {
      Content.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents.push(Content.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      contents: globalThis.Array.isArray(object?.contents) ? object.contents.map((e: any) => Content.fromJSON(e)) : [],
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.contents?.length) {
      obj.contents = message.contents.map((e) => Content.toJSON(e));
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map((e) => ToolCall.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.role = object.role ?? "";
    message.contents = object.contents?.map((e) => Content.fromPartial(e)) || [];
    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvent(): Event {
  return { name: "", meta: undefined, time: undefined };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.meta !== undefined) {
      Struct.encode(Struct.wrap(message.meta), writer.uint32(18).fork()).join();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      meta: isObject(object.meta) ? object.meta : undefined,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.meta !== undefined) {
      obj.meta = message.meta;
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.name = object.name ?? "";
    message.meta = object.meta ?? undefined;
    message.time = object.time ?? undefined;
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { id: "", type: "", function: undefined };
}

export const ToolCall: MessageFns<ToolCall> = {
  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.function !== undefined) {
      FunctionCall.encode(message.function, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.function = FunctionCall.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      function: isSet(object.function) ? FunctionCall.fromJSON(object.function) : undefined,
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.function !== undefined) {
      obj.function = FunctionCall.toJSON(message.function);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.function = (object.function !== undefined && object.function !== null)
      ? FunctionCall.fromPartial(object.function)
      : undefined;
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { name: "", arguments: "", args: undefined };
}

export const FunctionCall: MessageFns<FunctionCall> = {
  encode(message: FunctionCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arguments !== "") {
      writer.uint32(18).string(message.arguments);
    }
    if (message.args !== undefined) {
      Struct.encode(Struct.wrap(message.args), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : "",
      args: isObject(object.args) ? object.args : undefined,
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arguments !== "") {
      obj.arguments = message.arguments;
    }
    if (message.args !== undefined) {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionCall>, I>>(base?: I): FunctionCall {
    return FunctionCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionCall>, I>>(object: I): FunctionCall {
    const message = createBaseFunctionCall();
    message.name = object.name ?? "";
    message.arguments = object.arguments ?? "";
    message.args = object.args ?? undefined;
    return message;
  },
};

function createBaseKnowledge(): Knowledge {
  return {
    id: 0,
    name: "",
    description: "",
    visibility: "",
    language: "",
    embeddingProviderModelId: 0,
    embeddingProviderModel: undefined,
    status: "",
    createdBy: 0,
    createdUser: undefined,
    updatedBy: 0,
    updatedUser: undefined,
    createdDate: undefined,
    updatedDate: undefined,
    organizationId: 0,
    projectId: 0,
    organization: undefined,
    knowledgeTag: undefined,
    documentCount: 0,
    tokenCount: 0,
    wordCount: 0,
    embeddingProviderId: 0,
  };
}

export const Knowledge: MessageFns<Knowledge> = {
  encode(message: Knowledge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.visibility !== "") {
      writer.uint32(34).string(message.visibility);
    }
    if (message.language !== "") {
      writer.uint32(42).string(message.language);
    }
    if (message.embeddingProviderModelId !== 0) {
      writer.uint32(48).uint64(message.embeddingProviderModelId);
    }
    if (message.embeddingProviderModel !== undefined) {
      ProviderModel.encode(message.embeddingProviderModel, writer.uint32(58).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(98).string(message.status);
    }
    if (message.createdBy !== 0) {
      writer.uint32(104).uint64(message.createdBy);
    }
    if (message.createdUser !== undefined) {
      User.encode(message.createdUser, writer.uint32(114).fork()).join();
    }
    if (message.updatedBy !== 0) {
      writer.uint32(120).uint64(message.updatedBy);
    }
    if (message.updatedUser !== undefined) {
      User.encode(message.updatedUser, writer.uint32(130).fork()).join();
    }
    if (message.createdDate !== undefined) {
      Timestamp.encode(toTimestamp(message.createdDate), writer.uint32(138).fork()).join();
    }
    if (message.updatedDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedDate), writer.uint32(146).fork()).join();
    }
    if (message.organizationId !== 0) {
      writer.uint32(152).uint64(message.organizationId);
    }
    if (message.projectId !== 0) {
      writer.uint32(160).uint64(message.projectId);
    }
    if (message.organization !== undefined) {
      Organization.encode(message.organization, writer.uint32(170).fork()).join();
    }
    if (message.knowledgeTag !== undefined) {
      Tag.encode(message.knowledgeTag, writer.uint32(178).fork()).join();
    }
    if (message.documentCount !== 0) {
      writer.uint32(184).uint32(message.documentCount);
    }
    if (message.tokenCount !== 0) {
      writer.uint32(192).uint32(message.tokenCount);
    }
    if (message.wordCount !== 0) {
      writer.uint32(200).uint32(message.wordCount);
    }
    if (message.embeddingProviderId !== 0) {
      writer.uint32(208).uint64(message.embeddingProviderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Knowledge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.visibility = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.embeddingProviderModelId = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.embeddingProviderModel = ProviderModel.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.createdBy = longToNumber(reader.uint64());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.updatedBy = longToNumber(reader.uint64());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.createdDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.updatedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.organizationId = longToNumber(reader.uint64());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.projectId = longToNumber(reader.uint64());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.organization = Organization.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.knowledgeTag = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.documentCount = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.tokenCount = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.wordCount = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.embeddingProviderId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Knowledge {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      visibility: isSet(object.visibility) ? globalThis.String(object.visibility) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      embeddingProviderModelId: isSet(object.embeddingProviderModelId)
        ? globalThis.Number(object.embeddingProviderModelId)
        : 0,
      embeddingProviderModel: isSet(object.embeddingProviderModel)
        ? ProviderModel.fromJSON(object.embeddingProviderModel)
        : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdBy: isSet(object.createdBy) ? globalThis.Number(object.createdBy) : 0,
      createdUser: isSet(object.createdUser) ? User.fromJSON(object.createdUser) : undefined,
      updatedBy: isSet(object.updatedBy) ? globalThis.Number(object.updatedBy) : 0,
      updatedUser: isSet(object.updatedUser) ? User.fromJSON(object.updatedUser) : undefined,
      createdDate: isSet(object.createdDate) ? fromJsonTimestamp(object.createdDate) : undefined,
      updatedDate: isSet(object.updatedDate) ? fromJsonTimestamp(object.updatedDate) : undefined,
      organizationId: isSet(object.organizationId) ? globalThis.Number(object.organizationId) : 0,
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      organization: isSet(object.organization) ? Organization.fromJSON(object.organization) : undefined,
      knowledgeTag: isSet(object.knowledgeTag) ? Tag.fromJSON(object.knowledgeTag) : undefined,
      documentCount: isSet(object.documentCount) ? globalThis.Number(object.documentCount) : 0,
      tokenCount: isSet(object.tokenCount) ? globalThis.Number(object.tokenCount) : 0,
      wordCount: isSet(object.wordCount) ? globalThis.Number(object.wordCount) : 0,
      embeddingProviderId: isSet(object.embeddingProviderId) ? globalThis.Number(object.embeddingProviderId) : 0,
    };
  },

  toJSON(message: Knowledge): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.visibility !== "") {
      obj.visibility = message.visibility;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.embeddingProviderModelId !== 0) {
      obj.embeddingProviderModelId = Math.round(message.embeddingProviderModelId);
    }
    if (message.embeddingProviderModel !== undefined) {
      obj.embeddingProviderModel = ProviderModel.toJSON(message.embeddingProviderModel);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdBy !== 0) {
      obj.createdBy = Math.round(message.createdBy);
    }
    if (message.createdUser !== undefined) {
      obj.createdUser = User.toJSON(message.createdUser);
    }
    if (message.updatedBy !== 0) {
      obj.updatedBy = Math.round(message.updatedBy);
    }
    if (message.updatedUser !== undefined) {
      obj.updatedUser = User.toJSON(message.updatedUser);
    }
    if (message.createdDate !== undefined) {
      obj.createdDate = message.createdDate.toISOString();
    }
    if (message.updatedDate !== undefined) {
      obj.updatedDate = message.updatedDate.toISOString();
    }
    if (message.organizationId !== 0) {
      obj.organizationId = Math.round(message.organizationId);
    }
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.organization !== undefined) {
      obj.organization = Organization.toJSON(message.organization);
    }
    if (message.knowledgeTag !== undefined) {
      obj.knowledgeTag = Tag.toJSON(message.knowledgeTag);
    }
    if (message.documentCount !== 0) {
      obj.documentCount = Math.round(message.documentCount);
    }
    if (message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    if (message.wordCount !== 0) {
      obj.wordCount = Math.round(message.wordCount);
    }
    if (message.embeddingProviderId !== 0) {
      obj.embeddingProviderId = Math.round(message.embeddingProviderId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Knowledge>, I>>(base?: I): Knowledge {
    return Knowledge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Knowledge>, I>>(object: I): Knowledge {
    const message = createBaseKnowledge();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.visibility = object.visibility ?? "";
    message.language = object.language ?? "";
    message.embeddingProviderModelId = object.embeddingProviderModelId ?? 0;
    message.embeddingProviderModel =
      (object.embeddingProviderModel !== undefined && object.embeddingProviderModel !== null)
        ? ProviderModel.fromPartial(object.embeddingProviderModel)
        : undefined;
    message.status = object.status ?? "";
    message.createdBy = object.createdBy ?? 0;
    message.createdUser = (object.createdUser !== undefined && object.createdUser !== null)
      ? User.fromPartial(object.createdUser)
      : undefined;
    message.updatedBy = object.updatedBy ?? 0;
    message.updatedUser = (object.updatedUser !== undefined && object.updatedUser !== null)
      ? User.fromPartial(object.updatedUser)
      : undefined;
    message.createdDate = object.createdDate ?? undefined;
    message.updatedDate = object.updatedDate ?? undefined;
    message.organizationId = object.organizationId ?? 0;
    message.projectId = object.projectId ?? 0;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? Organization.fromPartial(object.organization)
      : undefined;
    message.knowledgeTag = (object.knowledgeTag !== undefined && object.knowledgeTag !== null)
      ? Tag.fromPartial(object.knowledgeTag)
      : undefined;
    message.documentCount = object.documentCount ?? 0;
    message.tokenCount = object.tokenCount ?? 0;
    message.wordCount = object.wordCount ?? 0;
    message.embeddingProviderId = object.embeddingProviderId ?? 0;
    return message;
  },
};

function createBaseAgentPromptTemplate(): AgentPromptTemplate {
  return { type: "", prompt: "", promptVariables: [] };
}

export const AgentPromptTemplate: MessageFns<AgentPromptTemplate> = {
  encode(message: AgentPromptTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.prompt !== "") {
      writer.uint32(18).string(message.prompt);
    }
    for (const v of message.promptVariables) {
      Variable.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentPromptTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentPromptTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.promptVariables.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentPromptTemplate {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      promptVariables: globalThis.Array.isArray(object?.promptVariables)
        ? object.promptVariables.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgentPromptTemplate): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.promptVariables?.length) {
      obj.promptVariables = message.promptVariables.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentPromptTemplate>, I>>(base?: I): AgentPromptTemplate {
    return AgentPromptTemplate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentPromptTemplate>, I>>(object: I): AgentPromptTemplate {
    const message = createBaseAgentPromptTemplate();
    message.type = object.type ?? "";
    message.prompt = object.prompt ?? "";
    message.promptVariables = object.promptVariables?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTextPrompt(): TextPrompt {
  return { role: "", content: "" };
}

export const TextPrompt: MessageFns<TextPrompt> = {
  encode(message: TextPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextPrompt {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: TextPrompt): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextPrompt>, I>>(base?: I): TextPrompt {
    return TextPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextPrompt>, I>>(object: I): TextPrompt {
    const message = createBaseTextPrompt();
    message.role = object.role ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseFilePrompt(): FilePrompt {
  return { name: "", accepts: "" };
}

export const FilePrompt: MessageFns<FilePrompt> = {
  encode(message: FilePrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accepts !== "") {
      writer.uint32(18).string(message.accepts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accepts = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilePrompt {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accepts: isSet(object.accepts) ? globalThis.String(object.accepts) : "",
    };
  },

  toJSON(message: FilePrompt): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accepts !== "") {
      obj.accepts = message.accepts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilePrompt>, I>>(base?: I): FilePrompt {
    return FilePrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilePrompt>, I>>(object: I): FilePrompt {
    const message = createBaseFilePrompt();
    message.name = object.name ?? "";
    message.accepts = object.accepts ?? "";
    return message;
  },
};

function createBaseTextChatCompletePrompt(): TextChatCompletePrompt {
  return { prompt: [], promptVariables: [] };
}

export const TextChatCompletePrompt: MessageFns<TextChatCompletePrompt> = {
  encode(message: TextChatCompletePrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prompt) {
      TextPrompt.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.promptVariables) {
      Variable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextChatCompletePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextChatCompletePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt.push(TextPrompt.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptVariables.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextChatCompletePrompt {
    return {
      prompt: globalThis.Array.isArray(object?.prompt) ? object.prompt.map((e: any) => TextPrompt.fromJSON(e)) : [],
      promptVariables: globalThis.Array.isArray(object?.promptVariables)
        ? object.promptVariables.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TextChatCompletePrompt): unknown {
    const obj: any = {};
    if (message.prompt?.length) {
      obj.prompt = message.prompt.map((e) => TextPrompt.toJSON(e));
    }
    if (message.promptVariables?.length) {
      obj.promptVariables = message.promptVariables.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextChatCompletePrompt>, I>>(base?: I): TextChatCompletePrompt {
    return TextChatCompletePrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextChatCompletePrompt>, I>>(object: I): TextChatCompletePrompt {
    const message = createBaseTextChatCompletePrompt();
    message.prompt = object.prompt?.map((e) => TextPrompt.fromPartial(e)) || [];
    message.promptVariables = object.promptVariables?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTextCompletePrompt(): TextCompletePrompt {
  return { prompt: undefined, promptVariables: [] };
}

export const TextCompletePrompt: MessageFns<TextCompletePrompt> = {
  encode(message: TextCompletePrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== undefined) {
      TextPrompt.encode(message.prompt, writer.uint32(10).fork()).join();
    }
    for (const v of message.promptVariables) {
      Variable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextCompletePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextCompletePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = TextPrompt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptVariables.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextCompletePrompt {
    return {
      prompt: isSet(object.prompt) ? TextPrompt.fromJSON(object.prompt) : undefined,
      promptVariables: globalThis.Array.isArray(object?.promptVariables)
        ? object.promptVariables.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TextCompletePrompt): unknown {
    const obj: any = {};
    if (message.prompt !== undefined) {
      obj.prompt = TextPrompt.toJSON(message.prompt);
    }
    if (message.promptVariables?.length) {
      obj.promptVariables = message.promptVariables.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextCompletePrompt>, I>>(base?: I): TextCompletePrompt {
    return TextCompletePrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextCompletePrompt>, I>>(object: I): TextCompletePrompt {
    const message = createBaseTextCompletePrompt();
    message.prompt = (object.prompt !== undefined && object.prompt !== null)
      ? TextPrompt.fromPartial(object.prompt)
      : undefined;
    message.promptVariables = object.promptVariables?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTextToImagePrompt(): TextToImagePrompt {
  return { prompt: undefined, promptVariables: [] };
}

export const TextToImagePrompt: MessageFns<TextToImagePrompt> = {
  encode(message: TextToImagePrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== undefined) {
      TextPrompt.encode(message.prompt, writer.uint32(10).fork()).join();
    }
    for (const v of message.promptVariables) {
      Variable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextToImagePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextToImagePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = TextPrompt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptVariables.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextToImagePrompt {
    return {
      prompt: isSet(object.prompt) ? TextPrompt.fromJSON(object.prompt) : undefined,
      promptVariables: globalThis.Array.isArray(object?.promptVariables)
        ? object.promptVariables.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TextToImagePrompt): unknown {
    const obj: any = {};
    if (message.prompt !== undefined) {
      obj.prompt = TextPrompt.toJSON(message.prompt);
    }
    if (message.promptVariables?.length) {
      obj.promptVariables = message.promptVariables.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextToImagePrompt>, I>>(base?: I): TextToImagePrompt {
    return TextToImagePrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextToImagePrompt>, I>>(object: I): TextToImagePrompt {
    const message = createBaseTextToImagePrompt();
    message.prompt = (object.prompt !== undefined && object.prompt !== null)
      ? TextPrompt.fromPartial(object.prompt)
      : undefined;
    message.promptVariables = object.promptVariables?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTextToSpeechPrompt(): TextToSpeechPrompt {
  return { prompt: undefined, promptVariables: [] };
}

export const TextToSpeechPrompt: MessageFns<TextToSpeechPrompt> = {
  encode(message: TextToSpeechPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== undefined) {
      TextPrompt.encode(message.prompt, writer.uint32(10).fork()).join();
    }
    for (const v of message.promptVariables) {
      Variable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextToSpeechPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextToSpeechPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = TextPrompt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptVariables.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextToSpeechPrompt {
    return {
      prompt: isSet(object.prompt) ? TextPrompt.fromJSON(object.prompt) : undefined,
      promptVariables: globalThis.Array.isArray(object?.promptVariables)
        ? object.promptVariables.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TextToSpeechPrompt): unknown {
    const obj: any = {};
    if (message.prompt !== undefined) {
      obj.prompt = TextPrompt.toJSON(message.prompt);
    }
    if (message.promptVariables?.length) {
      obj.promptVariables = message.promptVariables.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextToSpeechPrompt>, I>>(base?: I): TextToSpeechPrompt {
    return TextToSpeechPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextToSpeechPrompt>, I>>(object: I): TextToSpeechPrompt {
    const message = createBaseTextToSpeechPrompt();
    message.prompt = (object.prompt !== undefined && object.prompt !== null)
      ? TextPrompt.fromPartial(object.prompt)
      : undefined;
    message.promptVariables = object.promptVariables?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpeechToTextPrompt(): SpeechToTextPrompt {
  return { prompt: undefined, promptVariables: [] };
}

export const SpeechToTextPrompt: MessageFns<SpeechToTextPrompt> = {
  encode(message: SpeechToTextPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== undefined) {
      FilePrompt.encode(message.prompt, writer.uint32(10).fork()).join();
    }
    for (const v of message.promptVariables) {
      Variable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechToTextPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechToTextPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = FilePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptVariables.push(Variable.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechToTextPrompt {
    return {
      prompt: isSet(object.prompt) ? FilePrompt.fromJSON(object.prompt) : undefined,
      promptVariables: globalThis.Array.isArray(object?.promptVariables)
        ? object.promptVariables.map((e: any) => Variable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SpeechToTextPrompt): unknown {
    const obj: any = {};
    if (message.prompt !== undefined) {
      obj.prompt = FilePrompt.toJSON(message.prompt);
    }
    if (message.promptVariables?.length) {
      obj.promptVariables = message.promptVariables.map((e) => Variable.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpeechToTextPrompt>, I>>(base?: I): SpeechToTextPrompt {
    return SpeechToTextPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpeechToTextPrompt>, I>>(object: I): SpeechToTextPrompt {
    const message = createBaseSpeechToTextPrompt();
    message.prompt = (object.prompt !== undefined && object.prompt !== null)
      ? FilePrompt.fromPartial(object.prompt)
      : undefined;
    message.promptVariables = object.promptVariables?.map((e) => Variable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssistantMessageStage(): AssistantMessageStage {
  return {
    stage: "",
    additionalData: {},
    timetaken: 0,
    lifecycleId: "",
    startTimestamp: undefined,
    endTimestamp: undefined,
  };
}

export const AssistantMessageStage: MessageFns<AssistantMessageStage> = {
  encode(message: AssistantMessageStage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stage !== "") {
      writer.uint32(10).string(message.stage);
    }
    Object.entries(message.additionalData).forEach(([key, value]) => {
      AssistantMessageStage_AdditionalDataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.timetaken !== 0) {
      writer.uint32(24).uint64(message.timetaken);
    }
    if (message.lifecycleId !== "") {
      writer.uint32(34).string(message.lifecycleId);
    }
    if (message.startTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.startTimestamp), writer.uint32(42).fork()).join();
    }
    if (message.endTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.endTimestamp), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistantMessageStage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistantMessageStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = AssistantMessageStage_AdditionalDataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.additionalData[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timetaken = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lifecycleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistantMessageStage {
    return {
      stage: isSet(object.stage) ? globalThis.String(object.stage) : "",
      additionalData: isObject(object.additionalData)
        ? Object.entries(object.additionalData).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      timetaken: isSet(object.timetaken) ? globalThis.Number(object.timetaken) : 0,
      lifecycleId: isSet(object.lifecycleId) ? globalThis.String(object.lifecycleId) : "",
      startTimestamp: isSet(object.startTimestamp) ? fromJsonTimestamp(object.startTimestamp) : undefined,
      endTimestamp: isSet(object.endTimestamp) ? fromJsonTimestamp(object.endTimestamp) : undefined,
    };
  },

  toJSON(message: AssistantMessageStage): unknown {
    const obj: any = {};
    if (message.stage !== "") {
      obj.stage = message.stage;
    }
    if (message.additionalData) {
      const entries = Object.entries(message.additionalData);
      if (entries.length > 0) {
        obj.additionalData = {};
        entries.forEach(([k, v]) => {
          obj.additionalData[k] = v;
        });
      }
    }
    if (message.timetaken !== 0) {
      obj.timetaken = Math.round(message.timetaken);
    }
    if (message.lifecycleId !== "") {
      obj.lifecycleId = message.lifecycleId;
    }
    if (message.startTimestamp !== undefined) {
      obj.startTimestamp = message.startTimestamp.toISOString();
    }
    if (message.endTimestamp !== undefined) {
      obj.endTimestamp = message.endTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssistantMessageStage>, I>>(base?: I): AssistantMessageStage {
    return AssistantMessageStage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssistantMessageStage>, I>>(object: I): AssistantMessageStage {
    const message = createBaseAssistantMessageStage();
    message.stage = object.stage ?? "";
    message.additionalData = Object.entries(object.additionalData ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timetaken = object.timetaken ?? 0;
    message.lifecycleId = object.lifecycleId ?? "";
    message.startTimestamp = object.startTimestamp ?? undefined;
    message.endTimestamp = object.endTimestamp ?? undefined;
    return message;
  },
};

function createBaseAssistantMessageStage_AdditionalDataEntry(): AssistantMessageStage_AdditionalDataEntry {
  return { key: "", value: "" };
}

export const AssistantMessageStage_AdditionalDataEntry: MessageFns<AssistantMessageStage_AdditionalDataEntry> = {
  encode(message: AssistantMessageStage_AdditionalDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistantMessageStage_AdditionalDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistantMessageStage_AdditionalDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistantMessageStage_AdditionalDataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssistantMessageStage_AdditionalDataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssistantMessageStage_AdditionalDataEntry>, I>>(
    base?: I,
  ): AssistantMessageStage_AdditionalDataEntry {
    return AssistantMessageStage_AdditionalDataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssistantMessageStage_AdditionalDataEntry>, I>>(
    object: I,
  ): AssistantMessageStage_AdditionalDataEntry {
    const message = createBaseAssistantMessageStage_AdditionalDataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAssistantConversationMessage(): AssistantConversationMessage {
  return {
    id: 0,
    messageId: "",
    assistantConversationId: 0,
    request: undefined,
    response: undefined,
    source: "",
    metrics: [],
    status: "",
    createdBy: 0,
    updatedBy: 0,
    suggestedQuestions: [],
    stages: [],
    createdDate: undefined,
    updatedDate: undefined,
    assistantId: 0,
    assistantProviderModelId: 0,
    metadata: [],
  };
}

export const AssistantConversationMessage: MessageFns<AssistantConversationMessage> = {
  encode(message: AssistantConversationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.messageId !== "") {
      writer.uint32(26).string(message.messageId);
    }
    if (message.assistantConversationId !== 0) {
      writer.uint32(16).uint64(message.assistantConversationId);
    }
    if (message.request !== undefined) {
      Message.encode(message.request, writer.uint32(42).fork()).join();
    }
    if (message.response !== undefined) {
      Message.encode(message.response, writer.uint32(58).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(74).string(message.source);
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.createdBy !== 0) {
      writer.uint32(96).uint64(message.createdBy);
    }
    if (message.updatedBy !== 0) {
      writer.uint32(104).uint64(message.updatedBy);
    }
    for (const v of message.suggestedQuestions) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.stages) {
      AssistantMessageStage.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.createdDate !== undefined) {
      Timestamp.encode(toTimestamp(message.createdDate), writer.uint32(210).fork()).join();
    }
    if (message.updatedDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedDate), writer.uint32(218).fork()).join();
    }
    if (message.assistantId !== 0) {
      writer.uint32(224).uint64(message.assistantId);
    }
    if (message.assistantProviderModelId !== 0) {
      writer.uint32(232).uint64(message.assistantProviderModelId);
    }
    for (const v of message.metadata) {
      Metadata.encode(v!, writer.uint32(250).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistantConversationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistantConversationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.assistantConversationId = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.request = Message.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.response = Message.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.createdBy = longToNumber(reader.uint64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.updatedBy = longToNumber(reader.uint64());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.suggestedQuestions.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.stages.push(AssistantMessageStage.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.createdDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.updatedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.assistantId = longToNumber(reader.uint64());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.assistantProviderModelId = longToNumber(reader.uint64());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.metadata.push(Metadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistantConversationMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      assistantConversationId: isSet(object.assistantConversationId)
        ? globalThis.Number(object.assistantConversationId)
        : 0,
      request: isSet(object.request) ? Message.fromJSON(object.request) : undefined,
      response: isSet(object.response) ? Message.fromJSON(object.response) : undefined,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdBy: isSet(object.createdBy) ? globalThis.Number(object.createdBy) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.Number(object.updatedBy) : 0,
      suggestedQuestions: globalThis.Array.isArray(object?.suggestedQuestions)
        ? object.suggestedQuestions.map((e: any) => globalThis.String(e))
        : [],
      stages: globalThis.Array.isArray(object?.stages)
        ? object.stages.map((e: any) => AssistantMessageStage.fromJSON(e))
        : [],
      createdDate: isSet(object.createdDate) ? fromJsonTimestamp(object.createdDate) : undefined,
      updatedDate: isSet(object.updatedDate) ? fromJsonTimestamp(object.updatedDate) : undefined,
      assistantId: isSet(object.assistantId) ? globalThis.Number(object.assistantId) : 0,
      assistantProviderModelId: isSet(object.assistantProviderModelId)
        ? globalThis.Number(object.assistantProviderModelId)
        : 0,
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => Metadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AssistantConversationMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.assistantConversationId !== 0) {
      obj.assistantConversationId = Math.round(message.assistantConversationId);
    }
    if (message.request !== undefined) {
      obj.request = Message.toJSON(message.request);
    }
    if (message.response !== undefined) {
      obj.response = Message.toJSON(message.response);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdBy !== 0) {
      obj.createdBy = Math.round(message.createdBy);
    }
    if (message.updatedBy !== 0) {
      obj.updatedBy = Math.round(message.updatedBy);
    }
    if (message.suggestedQuestions?.length) {
      obj.suggestedQuestions = message.suggestedQuestions;
    }
    if (message.stages?.length) {
      obj.stages = message.stages.map((e) => AssistantMessageStage.toJSON(e));
    }
    if (message.createdDate !== undefined) {
      obj.createdDate = message.createdDate.toISOString();
    }
    if (message.updatedDate !== undefined) {
      obj.updatedDate = message.updatedDate.toISOString();
    }
    if (message.assistantId !== 0) {
      obj.assistantId = Math.round(message.assistantId);
    }
    if (message.assistantProviderModelId !== 0) {
      obj.assistantProviderModelId = Math.round(message.assistantProviderModelId);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => Metadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssistantConversationMessage>, I>>(base?: I): AssistantConversationMessage {
    return AssistantConversationMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssistantConversationMessage>, I>>(object: I): AssistantConversationMessage {
    const message = createBaseAssistantConversationMessage();
    message.id = object.id ?? 0;
    message.messageId = object.messageId ?? "";
    message.assistantConversationId = object.assistantConversationId ?? 0;
    message.request = (object.request !== undefined && object.request !== null)
      ? Message.fromPartial(object.request)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? Message.fromPartial(object.response)
      : undefined;
    message.source = object.source ?? "";
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.createdBy = object.createdBy ?? 0;
    message.updatedBy = object.updatedBy ?? 0;
    message.suggestedQuestions = object.suggestedQuestions?.map((e) => e) || [];
    message.stages = object.stages?.map((e) => AssistantMessageStage.fromPartial(e)) || [];
    message.createdDate = object.createdDate ?? undefined;
    message.updatedDate = object.updatedDate ?? undefined;
    message.assistantId = object.assistantId ?? 0;
    message.assistantProviderModelId = object.assistantProviderModelId ?? 0;
    message.metadata = object.metadata?.map((e) => Metadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssistantConversationContext(): AssistantConversationContext {
  return { id: 0, context: "", metadata: undefined };
}

export const AssistantConversationContext: MessageFns<AssistantConversationContext> = {
  encode(message: AssistantConversationContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistantConversationContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistantConversationContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistantConversationContext {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: AssistantConversationContext): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssistantConversationContext>, I>>(base?: I): AssistantConversationContext {
    return AssistantConversationContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssistantConversationContext>, I>>(object: I): AssistantConversationContext {
    const message = createBaseAssistantConversationContext();
    message.id = object.id ?? 0;
    message.context = object.context ?? "";
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseAssistantConversation(): AssistantConversation {
  return {
    id: 0,
    userId: 0,
    assistantId: 0,
    name: "",
    projectId: 0,
    organizationId: 0,
    source: "",
    createdBy: 0,
    updatedBy: 0,
    user: undefined,
    assistantProviderModelId: 0,
    assistantConversationMessage: [],
    identifier: "",
    status: "",
    createdDate: undefined,
    updatedDate: undefined,
    contexts: [],
    metrics: [],
    metadata: [],
  };
}

export const AssistantConversation: MessageFns<AssistantConversation> = {
  encode(message: AssistantConversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).uint64(message.userId);
    }
    if (message.assistantId !== 0) {
      writer.uint32(24).uint64(message.assistantId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.projectId !== 0) {
      writer.uint32(40).uint64(message.projectId);
    }
    if (message.organizationId !== 0) {
      writer.uint32(48).uint64(message.organizationId);
    }
    if (message.source !== "") {
      writer.uint32(58).string(message.source);
    }
    if (message.createdBy !== 0) {
      writer.uint32(64).uint64(message.createdBy);
    }
    if (message.updatedBy !== 0) {
      writer.uint32(72).uint64(message.updatedBy);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(82).fork()).join();
    }
    if (message.assistantProviderModelId !== 0) {
      writer.uint32(96).uint64(message.assistantProviderModelId);
    }
    for (const v of message.assistantConversationMessage) {
      AssistantConversationMessage.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.identifier !== "") {
      writer.uint32(114).string(message.identifier);
    }
    if (message.status !== "") {
      writer.uint32(122).string(message.status);
    }
    if (message.createdDate !== undefined) {
      Timestamp.encode(toTimestamp(message.createdDate), writer.uint32(210).fork()).join();
    }
    if (message.updatedDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedDate), writer.uint32(218).fork()).join();
    }
    for (const v of message.contexts) {
      AssistantConversationContext.encode(v!, writer.uint32(226).fork()).join();
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(242).fork()).join();
    }
    for (const v of message.metadata) {
      Metadata.encode(v!, writer.uint32(258).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistantConversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistantConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.assistantId = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.projectId = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.organizationId = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdBy = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.updatedBy = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.assistantProviderModelId = longToNumber(reader.uint64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.assistantConversationMessage.push(AssistantConversationMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.createdDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.updatedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.contexts.push(AssistantConversationContext.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.metadata.push(Metadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistantConversation {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      assistantId: isSet(object.assistantId) ? globalThis.Number(object.assistantId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      projectId: isSet(object.projectId) ? globalThis.Number(object.projectId) : 0,
      organizationId: isSet(object.organizationId) ? globalThis.Number(object.organizationId) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      createdBy: isSet(object.createdBy) ? globalThis.Number(object.createdBy) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.Number(object.updatedBy) : 0,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      assistantProviderModelId: isSet(object.assistantProviderModelId)
        ? globalThis.Number(object.assistantProviderModelId)
        : 0,
      assistantConversationMessage: globalThis.Array.isArray(object?.assistantConversationMessage)
        ? object.assistantConversationMessage.map((e: any) => AssistantConversationMessage.fromJSON(e))
        : [],
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdDate: isSet(object.createdDate) ? fromJsonTimestamp(object.createdDate) : undefined,
      updatedDate: isSet(object.updatedDate) ? fromJsonTimestamp(object.updatedDate) : undefined,
      contexts: globalThis.Array.isArray(object?.contexts)
        ? object.contexts.map((e: any) => AssistantConversationContext.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      metadata: globalThis.Array.isArray(object?.metadata) ? object.metadata.map((e: any) => Metadata.fromJSON(e)) : [],
    };
  },

  toJSON(message: AssistantConversation): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.assistantId !== 0) {
      obj.assistantId = Math.round(message.assistantId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.projectId !== 0) {
      obj.projectId = Math.round(message.projectId);
    }
    if (message.organizationId !== 0) {
      obj.organizationId = Math.round(message.organizationId);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.createdBy !== 0) {
      obj.createdBy = Math.round(message.createdBy);
    }
    if (message.updatedBy !== 0) {
      obj.updatedBy = Math.round(message.updatedBy);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.assistantProviderModelId !== 0) {
      obj.assistantProviderModelId = Math.round(message.assistantProviderModelId);
    }
    if (message.assistantConversationMessage?.length) {
      obj.assistantConversationMessage = message.assistantConversationMessage.map((e) =>
        AssistantConversationMessage.toJSON(e)
      );
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdDate !== undefined) {
      obj.createdDate = message.createdDate.toISOString();
    }
    if (message.updatedDate !== undefined) {
      obj.updatedDate = message.updatedDate.toISOString();
    }
    if (message.contexts?.length) {
      obj.contexts = message.contexts.map((e) => AssistantConversationContext.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => Metadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssistantConversation>, I>>(base?: I): AssistantConversation {
    return AssistantConversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssistantConversation>, I>>(object: I): AssistantConversation {
    const message = createBaseAssistantConversation();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.assistantId = object.assistantId ?? 0;
    message.name = object.name ?? "";
    message.projectId = object.projectId ?? 0;
    message.organizationId = object.organizationId ?? 0;
    message.source = object.source ?? "";
    message.createdBy = object.createdBy ?? 0;
    message.updatedBy = object.updatedBy ?? 0;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.assistantProviderModelId = object.assistantProviderModelId ?? 0;
    message.assistantConversationMessage =
      object.assistantConversationMessage?.map((e) => AssistantConversationMessage.fromPartial(e)) || [];
    message.identifier = object.identifier ?? "";
    message.status = object.status ?? "";
    message.createdDate = object.createdDate ?? undefined;
    message.updatedDate = object.updatedDate ?? undefined;
    message.contexts = object.contexts?.map((e) => AssistantConversationContext.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.metadata = object.metadata?.map((e) => Metadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllAssistantConversationRequest(): GetAllAssistantConversationRequest {
  return { assistantId: 0, paginate: undefined, criterias: [], source: 0 };
}

export const GetAllAssistantConversationRequest: MessageFns<GetAllAssistantConversationRequest> = {
  encode(message: GetAllAssistantConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assistantId !== 0) {
      writer.uint32(8).uint64(message.assistantId);
    }
    if (message.paginate !== undefined) {
      Paginate.encode(message.paginate, writer.uint32(18).fork()).join();
    }
    for (const v of message.criterias) {
      Criteria.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.source !== 0) {
      writer.uint32(56).int32(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllAssistantConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllAssistantConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.assistantId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paginate = Paginate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.criterias.push(Criteria.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllAssistantConversationRequest {
    return {
      assistantId: isSet(object.assistantId) ? globalThis.Number(object.assistantId) : 0,
      paginate: isSet(object.paginate) ? Paginate.fromJSON(object.paginate) : undefined,
      criterias: globalThis.Array.isArray(object?.criterias)
        ? object.criterias.map((e: any) => Criteria.fromJSON(e))
        : [],
      source: isSet(object.source) ? sourceFromJSON(object.source) : 0,
    };
  },

  toJSON(message: GetAllAssistantConversationRequest): unknown {
    const obj: any = {};
    if (message.assistantId !== 0) {
      obj.assistantId = Math.round(message.assistantId);
    }
    if (message.paginate !== undefined) {
      obj.paginate = Paginate.toJSON(message.paginate);
    }
    if (message.criterias?.length) {
      obj.criterias = message.criterias.map((e) => Criteria.toJSON(e));
    }
    if (message.source !== 0) {
      obj.source = sourceToJSON(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllAssistantConversationRequest>, I>>(
    base?: I,
  ): GetAllAssistantConversationRequest {
    return GetAllAssistantConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllAssistantConversationRequest>, I>>(
    object: I,
  ): GetAllAssistantConversationRequest {
    const message = createBaseGetAllAssistantConversationRequest();
    message.assistantId = object.assistantId ?? 0;
    message.paginate = (object.paginate !== undefined && object.paginate !== null)
      ? Paginate.fromPartial(object.paginate)
      : undefined;
    message.criterias = object.criterias?.map((e) => Criteria.fromPartial(e)) || [];
    message.source = object.source ?? 0;
    return message;
  },
};

function createBaseGetAllAssistantConversationResponse(): GetAllAssistantConversationResponse {
  return { code: 0, success: false, data: [], error: undefined, paginated: undefined };
}

export const GetAllAssistantConversationResponse: MessageFns<GetAllAssistantConversationResponse> = {
  encode(message: GetAllAssistantConversationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    for (const v of message.data) {
      AssistantConversation.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.paginated !== undefined) {
      Paginated.encode(message.paginated, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllAssistantConversationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllAssistantConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(AssistantConversation.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paginated = Paginated.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllAssistantConversationResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => AssistantConversation.fromJSON(e))
        : [],
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      paginated: isSet(object.paginated) ? Paginated.fromJSON(object.paginated) : undefined,
    };
  },

  toJSON(message: GetAllAssistantConversationResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => AssistantConversation.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.paginated !== undefined) {
      obj.paginated = Paginated.toJSON(message.paginated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllAssistantConversationResponse>, I>>(
    base?: I,
  ): GetAllAssistantConversationResponse {
    return GetAllAssistantConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllAssistantConversationResponse>, I>>(
    object: I,
  ): GetAllAssistantConversationResponse {
    const message = createBaseGetAllAssistantConversationResponse();
    message.code = object.code ?? 0;
    message.success = object.success ?? false;
    message.data = object.data?.map((e) => AssistantConversation.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.paginated = (object.paginated !== undefined && object.paginated !== null)
      ? Paginated.fromPartial(object.paginated)
      : undefined;
    return message;
  },
};

function createBaseGetAllConversationMessageRequest(): GetAllConversationMessageRequest {
  return {
    assistantId: 0,
    assistantConversationId: 0,
    paginate: undefined,
    criterias: [],
    order: undefined,
    source: 0,
  };
}

export const GetAllConversationMessageRequest: MessageFns<GetAllConversationMessageRequest> = {
  encode(message: GetAllConversationMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assistantId !== 0) {
      writer.uint32(8).uint64(message.assistantId);
    }
    if (message.assistantConversationId !== 0) {
      writer.uint32(16).uint64(message.assistantConversationId);
    }
    if (message.paginate !== undefined) {
      Paginate.encode(message.paginate, writer.uint32(26).fork()).join();
    }
    for (const v of message.criterias) {
      Criteria.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.order !== undefined) {
      Ordering.encode(message.order, writer.uint32(42).fork()).join();
    }
    if (message.source !== 0) {
      writer.uint32(56).int32(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllConversationMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllConversationMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.assistantId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.assistantConversationId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paginate = Paginate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.criterias.push(Criteria.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.order = Ordering.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllConversationMessageRequest {
    return {
      assistantId: isSet(object.assistantId) ? globalThis.Number(object.assistantId) : 0,
      assistantConversationId: isSet(object.assistantConversationId)
        ? globalThis.Number(object.assistantConversationId)
        : 0,
      paginate: isSet(object.paginate) ? Paginate.fromJSON(object.paginate) : undefined,
      criterias: globalThis.Array.isArray(object?.criterias)
        ? object.criterias.map((e: any) => Criteria.fromJSON(e))
        : [],
      order: isSet(object.order) ? Ordering.fromJSON(object.order) : undefined,
      source: isSet(object.source) ? sourceFromJSON(object.source) : 0,
    };
  },

  toJSON(message: GetAllConversationMessageRequest): unknown {
    const obj: any = {};
    if (message.assistantId !== 0) {
      obj.assistantId = Math.round(message.assistantId);
    }
    if (message.assistantConversationId !== 0) {
      obj.assistantConversationId = Math.round(message.assistantConversationId);
    }
    if (message.paginate !== undefined) {
      obj.paginate = Paginate.toJSON(message.paginate);
    }
    if (message.criterias?.length) {
      obj.criterias = message.criterias.map((e) => Criteria.toJSON(e));
    }
    if (message.order !== undefined) {
      obj.order = Ordering.toJSON(message.order);
    }
    if (message.source !== 0) {
      obj.source = sourceToJSON(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllConversationMessageRequest>, I>>(
    base?: I,
  ): GetAllConversationMessageRequest {
    return GetAllConversationMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllConversationMessageRequest>, I>>(
    object: I,
  ): GetAllConversationMessageRequest {
    const message = createBaseGetAllConversationMessageRequest();
    message.assistantId = object.assistantId ?? 0;
    message.assistantConversationId = object.assistantConversationId ?? 0;
    message.paginate = (object.paginate !== undefined && object.paginate !== null)
      ? Paginate.fromPartial(object.paginate)
      : undefined;
    message.criterias = object.criterias?.map((e) => Criteria.fromPartial(e)) || [];
    message.order = (object.order !== undefined && object.order !== null)
      ? Ordering.fromPartial(object.order)
      : undefined;
    message.source = object.source ?? 0;
    return message;
  },
};

function createBaseGetAllConversationMessageResponse(): GetAllConversationMessageResponse {
  return { code: 0, success: false, data: [], error: undefined, paginated: undefined };
}

export const GetAllConversationMessageResponse: MessageFns<GetAllConversationMessageResponse> = {
  encode(message: GetAllConversationMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    for (const v of message.data) {
      AssistantConversationMessage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.paginated !== undefined) {
      Paginated.encode(message.paginated, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllConversationMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllConversationMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data.push(AssistantConversationMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paginated = Paginated.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllConversationMessageResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => AssistantConversationMessage.fromJSON(e))
        : [],
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      paginated: isSet(object.paginated) ? Paginated.fromJSON(object.paginated) : undefined,
    };
  },

  toJSON(message: GetAllConversationMessageResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => AssistantConversationMessage.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.paginated !== undefined) {
      obj.paginated = Paginated.toJSON(message.paginated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllConversationMessageResponse>, I>>(
    base?: I,
  ): GetAllConversationMessageResponse {
    return GetAllConversationMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllConversationMessageResponse>, I>>(
    object: I,
  ): GetAllConversationMessageResponse {
    const message = createBaseGetAllConversationMessageResponse();
    message.code = object.code ?? 0;
    message.success = object.success ?? false;
    message.data = object.data?.map((e) => AssistantConversationMessage.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.paginated = (object.paginated !== undefined && object.paginated !== null)
      ? Paginated.fromPartial(object.paginated)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
